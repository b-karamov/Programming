Ответы на вопросы:
1. Опишите своими словами, в чем заключается принцип инкапсуляции, и какие средства в python помогают реализовывать этот принцип.
* Инкапсуляция - это свойство ООП, позволяющее закрыть доступ к некоторым параметрам класса извне. То есть инкапуслированное поле или метод - это своего рода немая переменная, которой оперирует класс, но не выставляет для общего пользования. Для того чтобы создать и затем обращаться к такой вещи, нужно в начале имени поставить два нижних подчеркивания. Вернуть аттрибут или метод можно с помощью доп. функций. Плюсы использования данного принципа заключаются в том, что:
- во-первых, код становится более безопасным, и другие пользователи не смогут сломать код;
- во-вторых, становится легче и быстрее работать с кодом, например, если нужно поменять название, то не нужно менять его везде, а только в том месте, где происходит вывод параметров. При этом пользователю не приходится запоминать новые способы доступа к переменным, он может обращаться старым способом.

2. Какие проблемы помогает решить наследование? Сформулируйте, какое отношение должно быть между родительским и дочерним объектами.
* Наследование помогает не копировать одно и то же несколько раз для разных классов. То есть у двух разных классов есть один и тот же базовый функционал, то удобнее просто реализовать этот функционал в общем предке, а потом наследовать его этими двумя классами. При это удобство заключается в том, что если мы хотим поменять что-то в базовом функционале, то это нужно будет делать только в одном месте, то есть в предке. Стоит заметить, что при наследовании от родителя к дочерним классам должна существовать некая логика, то есть мы не должны пытаться при определении класса "человек" наследоваться от класса "калькулятор", хотя человек и может делать то, что делает калькулятор, но логика здесь нарушена.

3. В чем суть полиморфизма? Почему в python он практически всегда реализуется сам по себе?
* Полиморфизм - это возможность класса использовать методы класса, которые еще не были созданы для предка, но будут созданы для потомков. Таким образом, можно придумать какорй-то общий функционал для базового класса, а потом уже доопределять его для каждого из дочерних. В python, например, print всегда вызывает метод __str__(self), но для каждого класса __str__ работает по-разному. Например, для списков есть один вывод, а для кортежей - другой, причем как они выводятся определено в каждом из классов. Таким образом, тут очевидное использование полиморфизма. 
